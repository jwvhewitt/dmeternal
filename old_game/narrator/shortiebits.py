from .plots import Plot,PlotError,PlotState,Chapter
from .. import context
from .. import items
from .. import maps
from .. import randmaps
from .. import waypoints
from .. import monsters
from .. import dialogue
from .. import services
from .. import teams
from .. import characters
from .. import namegen
import random
from .. import container
from .. import aid
from .. import stats
from .. import effects
from .. import animobs

# Shortie Done-in-one Dungeon Monkey Adventure
# - A small adventure, typically consisting of a single dungeon or wilderness
#   area.
# - Despite the limited area, see how interesting you can make it.
# - This will be dynamically loaded into an existing campaign.

class ShortieStub( Plot ):
    LABEL = "SHORTIE"

    # This plot gets placed in the global scripts and sets itself as the
    # "world" of its chapter. This means that all scenes generated by subplots
    # should be stored inside the plot itself, making cleanup easy. I hope.
    scope = True
    active = False

    SHORTIE_GRAMMAR = {
        # [ADVENTURE] is the top level token- it will expand into a number of
        # high level tokens. These eventually convert into subplot labels.
        "[zADVENTURE]": [ "[ADVENTURE]",
            ],
        "[ADVENTURE]": [ "[IMPERILED_PLACE] [ENEMY_BASE] [ENEMY_GOAL]",
            "[DUNGEON_ENTRANCE] [DUNGEON_CHALLENGE] [DUNGEON_GOAL]"
            ],
        "[DUNGEON_CHALLENGE]": [ "SDI_DUNGEON_LEVEL SDI_BLOCKED_PASSAGE",
            "SDI_BLOCKED_PASSAGE SDI_DUNGEON_TERROR", "SDI_DUNGEON_LEVEL SDI_DUNGEON_TERROR",
            "SDI_BLOCKED_PASSAGE SDI_DUNGEON_LEVEL",
            ],
        "[DUNGEON_ENTRANCE]": [ "SDI_VILLAGE SDI_DUNGEON_ENTRANCE",
            "SDI_DUNGEON_ENTRANCE", "SDI_DANGEROUS_PATH SDI_DUNGEON_ENTRANCE"
            ],
        "[DUNGEON_GOAL]": [ "SDI_BIGBOSS","SDI_BIGBEAST"
            ],
        "[ENEMY_BASE]": [ "SDI_ENEMY_FORT SDI_ENEMY_BARRACKS",
            "SDI_DANGEROUS_PATH SDI_ENEMY_FORT", "SDI_ENEMY_TERRITORY SDI_ENEMY_FORT",
            "SDI_ENEMY_TERRITORY SDI_ENEMY_FORT SDI_ENEMY_BARRACKS",
            "SDI_ENEMY_TERRITORY SDI_DUNGEON_ENTRANCE"
            ],

        "[ENEMY_GOAL]": [ "SDI_BIGBOSS","SDI_EVILPLAN"
            ],

        "[IMPERILED_PLACE]": [ "SDI_AMBUSH SDI_VILLAGE", "SDI_VILLAGE",
            "SDI_DANGEROUS_PATH SDI_DEFILED_PLACE", "SDI_DEFILED_PLACE",
            "SDI_DANGEROUS_PATH SDI_VILLAGE", "SDI_VILLAGE SDI_DEFILED_PLACE"
            ],
    }
    def custom_init( self, nart ):
        """Create the chapter."""
        self.chapter = Chapter( start_rank=nart.start_rank, end_rank=nart.end_rank, world=self )
        self.chapter.root = self
        self.contents = container.ContainerList(owner=self)
        self.rank = nart.start_rank
        if not self.setting:
            self.setting = context.SET_RENFAN

        # Generate a plot outline for the adventure. We will do this using a
        # context free grammar expansion of the token [ADVENTURE]. The resultant
        # string will be a list of subplot request labels.
        # Note that we don't want any repeating tokens, so try 100 times if need be.
        tries = 0
        while tries < 100:
            subplot_list = self.register_element( "SHORTIE_OUTLINE", list( dialogue.grammar.convert_tokens( "[zADVENTURE]", self.SHORTIE_GRAMMAR ).split() ) )
            tries += 1
            if len(subplot_list) == len(set(subplot_list)):
                # No repeat tokens. Let's get out of here.
                break

        # Assemble the outline into an adventure. Basically, add a subplot of
        # each generated type, in order. Each subplot describes a stage of the
        # mini adventure- usually a single scene, maybe also several scenes or
        # part of a scene, whatever.
        prev_subplot = self
        self.genplots = list()
        ident = None
        for spr in subplot_list:
            if spr is subplot_list[-1]:
                ident = "_conclusion"
            next_subplot = self.add_sub_plot( nart, spr,
                PlotState().based_on(prev_subplot), ident=ident )
            self.genplots.append( next_subplot )
            if prev_subplot != self:
                # Connect the OUT_ENTRANCE of the prev to the IN_ENTRANCE of the
                # next.
                pe,ne = prev_subplot.elements["OUT_ENTRANCE"], next_subplot.elements["IN_ENTRANCE"]
                pe.destination,pe.otherside = next_subplot.elements["IN_SCENE"],ne
                ne.destination,ne.otherside = prev_subplot.elements["OUT_SCENE"],pe
            # That which was new has now become old.
            prev_subplot = next_subplot

        # Set the adventure entrance to the IN_SCENE of the first generated
        # subplot.
        self._adventure_entrance = (self.genplots[0].elements.get( "IN_SCENE" ),self.genplots[0].elements.get( "IN_ENTRANCE" ))
        #exit = self.genplots[-1].elements.get( "OUT_ENTRANCE" )
        #self.register_element( "_EXIT", exit )
        #exit.plot_locked = True
        self.mr_subplot = self.genplots[0]

        self._do_message = True

        return True
    def any_duplicates(self,thelist):
        seen = set()
        for x in thelist:
            if x in seen:
                return True
            seen.add(x)
        return False
    def _EXIT_menu( self, thingmenu ):
        thingmenu.desc = "This appears to be the way out."
        thingmenu.add_item( "Leave this adventure.", self.use_exit )
        thingmenu.add_item( "Stay here a bit longer.", None )
    def _ENTRANCE_menu( self, thingmenu ):
        self._EXIT_menu( thingmenu )
    def use_exit( self, explo ):
        explo.alert( "[=CONCLUSION]" )
        explo.give_gold_and_xp( self.rank*150+random.randint(1,200), self.rank*150 + 350 )
        self.end_adventure( explo.camp )
    def _conclusion_WIN( self, explo ):
        # The conclusion has been won. Activate the exit.
        exit = self.genplots[-1].elements.get( "OUT_ENTRANCE" )
        self.register_element( "_EXIT", exit )
        exit.plot_locked = True
        exit = self.genplots[-1].elements.get( "IN_ENTRANCE" )
        self.register_element( "_ENTRANCE", exit )
        exit.plot_locked = True

    def begin_adventure( self, explo, exit_destination, exit_entrance ):
        # Unpack the adventure entrance stored during generation.
        self.active = True
        explo.camp.destination,explo.camp.entrance = self._adventure_entrance
        self._adventure_exit = (exit_destination, exit_entrance)
        explo.alert( "[=INTRO]" )

    def end_adventure( self, camp ):
        # Remove this adventure from campaign, move PCs to original place.
        camp.destination,camp.entrance = self._adventure_exit
        camp.scripts.remove( self )
        self.remove()

    DIALOGUE_GRAMMAR = {
        "[=CONCLUSION]": [ "After [-achievement] and [++achievement], you return home in victory.",
            "After [++achievement], you return to [quest_giver] for your reward.",
            "It's been a busy day, but [++achievement] is finally done. [END_SHORTIE]",
            "It wasn't easy [-achievement] and [++achievement]. [END_SHORTIE]"
            ],
        "[END_SHORTIE]": [ "You return home in victory.", "You return to [quest_giver] for your reward.",
            "Now you can finally begin that vacation.", "The bards will sing of your acts today.",
            ],
        "[=INTRO]": [ "You have been sent to bring [+SDI_BIGBOSS:name] the [+SDI_BIGBOSS:type] to justice. So far you have tracked them to [=location].",
            "The [+SDI_VILLAGE] has called for a hero. [INTRO_PROBLEM]",
            "You have come to [=location] for the purpose of [++achievement]. [INTRO_PROBLEM]"
            ],
        "[INTRO_PROBLEM]": [ "Travelers passing through [+SDI_AMBUSH:name] have gone missing.",
            "A [+SDI_BIGBOSS:type] named [+SDI_BIGBOSS:name] has been causing problems.",
            "[=SUMMARY]", "Someone [+villainous_act], and you intend to find out who."
            ],
        "[quest_giver]": [ "[-quest_giver]", "[=quest_giver]"
            ],
        "[RUMOUR]": [   "[rumourleadin] [warning].",
            "[++SDI_BIGBOSS:name] [villainous_act].", 
            "[rumourleadin] something [villainous_act]."
            ],
        "[SHORTIE_SUMMARY]": [ "You already know that [-warning].",
            "[=SUMMARY]", "[+SDI_BIGBOSS:name] [villainous_act]."
            "Something [villainous_act]."
            ],
        "[SHORTIE_PROBLEM]": [ "[++SUMMARY]","[+SUMMARY]",
            "What if [+SDI_BIGBOSS:name] [+villainous_act]?",
            ],
        "[villainous_act]": [ "[-villainous_act]","[=villainous_act]"
            ],
        "[villainous_motive]": [ "[=villainous_motive]","[+villainous_motive]",
            "[++villainous_motive]"
            ],
        "[warning]": [ "[+warning]","[=warning]",
            ],
    }

    def get_dialogue_grammar( self, npc, explo ):
        """Return any grammar rules appropriate to this situation."""
        gram = dialogue.grammar.absorb( dict(), self.DIALOGUE_GRAMMAR )
        prefix = "-"
        for sp in self.genplots:
            g2 = sp.get_sdi_grammar()
            if sp is self.mr_subplot:
                prefix = "="
            elif prefix == "=":
                prefix = "+"
            for k,v in g2.items():
                a,b,c = k.partition("[")
                mod_k = b + prefix + c
                if mod_k not in gram:
                    gram[mod_k] = list()
                gram[mod_k] += v
                if sp is self.genplots[-1]:
                    # Add a special mention for the conclusion.
                    mod_k = b + "++" + c
                    if mod_k not in gram:
                        gram[mod_k] = list()
                    gram[mod_k] += v
        return gram

    def t_START( self, explo ):
        if self._do_message:
            self._do_message = False
        # Determine the most recently entered subplot...
        for sp in self.genplots:
            if explo.scene is sp.elements["IN_SCENE"]:
                if self.genplots.index(sp) > self.genplots.index(self.mr_subplot):
                    self.mr_subplot = sp
    def t_COMBATOVER( self, explo ):
        # If the party has died, end this plot gracefully.
        if not explo.camp.first_living_pc():
            explo.camp.destination,explo.camp.entrance = self._adventure_exit
            explo.camp.scripts.remove( self )
            self.remove()

class SDIPlot( Plot ):
    # Like a normal plot, but with extra functions for shortie adventures.
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        # Grammar will be prefixed depending on position:
        # "-" for a subplot the PC has already visited
        # "=" for the current subplot
        # "+" for future subplots
        # "++" for the adventure conclusion
        return dict()

# Each shortie component should include:
# IN_SCENE,IN_ENTRANCE: Scene/Entrance where the subplot is entered.
# OUT_SCENE, OUT_ENTRANCE: Scene/Entrance where the subplot is exited.
#  -Note that IN_ENTRANCE need not be a valid gate; if not, transit from
#   previous subplot is one-way only.
#  -If OUT_ENTRANCE is plot_locked, unlock it before triggering WIN.
#
# Each shortie component can define the following SDI grammar tags:
#  [achievement] Subplot's win condition, in gerund (-ing) form. Can be omitted
#           if nothing much was achieved.
#  [GO_QUEST]   Describe the win condition for this subplot in imperative form.
#  [INTRO]  An introduction to be printed if the adventure starts in this
#           subplot.
#  [location]   A location of interest within the subplot. Optional.
#  [quest_giver] The NPC who sent the party on this mission, and will presumably
#           reward them afterward. Keep it current.
#  [SUMMARY]    A summary of subplot's state, written from player-aligned
#     perspective, in simple present tense.
#  [villainous_act] Something villainous done by the antagonist, in simple past.
#  [villainous_motive] Villainous motive, in "to infinitive" form.
#  [warning]    A caution for the PC. Frequently encountered as a rumour.
#
# 
#

# SDI_BIGBEAST
#
# Win Condition:
#   Kill the boss, usually.
# Grammar Tags:
#   [SDI_BIGBEAST:name]   The name of the boss
#   [SDI_BIGBEAST:type]   The type of the boss (optional)
# To do:
# - Mass of tiny bosses

class BasicBigBeast( SDIPlot ):
    # A simple building level with a direct bossfight.
    LABEL = "SDI_BIGBEAST"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Lair","{0}'s Den","{0}'s Cave")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        # We really want this beast's lair to be a cave. If the dungeon
        # architecture is already a cave- great! Keep it. Otherwise, forget
        # about it and generate a cave.
        cdungeon = randmaps.architect.CavernDungeon()
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",cdungeon )
        if biome.biome != context.HAB_CAVE:
            biome = cdungeon
        myscene,mymapgen = randmaps.architect.design_scene( min(30+self.rank,50),min(30+self.rank,50),
          randmaps.CaveScene, biome, setting=self.setting,
          fac=antagonist)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        anc_a,anc_b = random.choice( randmaps.anchors.OPPOSING_CARDINALS )
        team = teams.Team(default_reaction=-999, rank=self.rank, strength=200,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.FuzzyRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_a )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor(anchor=anc_a)
        goalroom.contents.append(door2)
        for t in range(2):
            mychest = random.choice([waypoints.MediumChest,waypoints.LargeChest])()
            mychest.stock(self.rank+1)
            goalroom.contents.append( mychest )

        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_BOSS ] = True
        myhabitat[(context.MTY_BEAST,context.MTY_ELEMENTAL,context.MTY_CONSTRUCT)] = True
        if antagonist:
            antagonist.alter_monster_request( myhabitat, force_membership=False )
        btype = monsters.choose_monster_type(self.rank+1,self.rank+3,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+3, team=team )
            goalroom.contents.append( boss )
            self.register_element( "ENEMY", boss )
            team.boss = boss
            myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )
            self.enemy_defeated = False

        entranceroom = randmaps.rooms.FuzzyRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.StairsUp(anchor=anc_b)
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return btype

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True
        explo.check_trigger( "WIN", self )
    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "slaying {}".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Slay {} the {}.".format(self.elements["ENEMY"],self.elements["ENEMY"].monster_name),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBEAST:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBEAST:type]": [self.elements["ENEMY"].monster_name,],
            "[SUMMARY]": [ "{} the {} [villainous_act].".format(self.elements["ENEMY"],self.elements["ENEMY"].monster_name),
                "{} is a dangerous {}.".format(self.elements["ENEMY"],self.elements["ENEMY"].monster_name),
                ],
            "[villainous_act]": [ "sowed death and destruction",
                ],
            "[villainous_motive]": [ "to satisfy its hunger",
                ],
            "[warning]":    ["{} is a powerful {}".format(self.elements["ENEMY"],self.elements["ENEMY"].monster_name),
                ],
        }
        return mygram


# SDI_BLOCKED_PASSAGE
#   You can progress no further in this dungeon until you do something.
# Win Condition:
#   Get to the end.
# Grammar Tags:
#   [SDI_BLOCKED_PASSAGE:location]    The name of the path.
# To do:
# - Secret door
# - Puzzle door

class BPDividedIslands( SDIPlot ):
    # The first half of this dungeon is separated from the second half.
    LABEL = "SDI_BLOCKED_PASSAGE"
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.TunnelDungeon(antagonist) )
        myscene,mymapgen = randmaps.architect.design_scene( 75,75, randmaps.DividedIslandScene,
          biome, setting=self.setting, fac=None)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,30)
        myscene.name = biome.name

        self.add_sub_plot( nart, "DIVIDED_ISLAND_COMPLICATION", ident="OPEN_DOOR" )

        goalroom = mymapgen.DEFAULT_ROOM( tags=(context.GOAL,), parent=myscene )
        door2 = waypoints.SpiralStairsDown()
        goalroom.contents.append(door2)

        entranceroom = mymapgen.DEFAULT_ROOM( tags=(context.ENTRANCE,), parent=myscene )
        door1 = waypoints.SpiralStairsUp()
        entranceroom.contents.append(door1)

        for t in range( random.randint(1,3) ):
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        if random.randint(1,3) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,3) != 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )
        else:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState(elements={"ANTAGONIST":antagonist}).based_on( self ) )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True
    def OPEN_DOOR_WIN( self, explo ):
        explo.check_trigger( "WIN", self )
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "passing through the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Find a way through the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BLOCKED_PASSAGE:location]": [str(self.elements["LOCALE"]),],
            "[SUMMARY]": [ "The passage through the {} is blocked.".format(self.elements["LOCALE"]),
                ],
            "[warning]":    ["there is no easy way through the {}".format(self.elements["LOCALE"]),
                ],
        }
        return mygram


# SDI_DANGEROUS_PATH
#   You have to travel along this road, but it's dangerous.
# Win Condition:
#   Get to the end.
# Grammar Tags:
#   [SDI_DANGEROUS_PATH:location]    The name of the path.
#   [SDI_DANGEROUS_PATH:threat]     The reason why the path is dangerous.
# To do:
# - Divided islands
# - Straightforward with encounter in the middle
# - Bandit lair: Lots of thieves
# - Murder house: Middle Earth Chainsaw Massacre
# - Through the mines: Over the mountain or through it

class ShortWildernessPath( SDIPlot ):
    LABEL = "SDI_DANGEROUS_PATH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    @classmethod
    def matches( self, pstate ):
        return pstate.rank < 5
    def custom_init( self, nart ):
        # Create the wilderness area.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )
        myscene.desctags.append( context.MTY_BEAST )
        #myscene.contents.append( randmaps.rooms.FuzzyRoom() )
        #myscene.contents.append( randmaps.rooms.FuzzyRoom() )

        self._do_message = True

        # Add some extra pressure.
        for t in range( random.randint(1,2) ):
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        elif random.randint(1,6) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Create the scene entrance and exit on opposite ends of the map.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_PAIRS)
        myroom1 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_a )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom1.contents.append( myent )

        myroom2 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_b )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        myroom2.contents.append( myexit )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "crossing the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Travel to the {}.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "You find yourselves completely lost in the {}. According to rumour, [+warning].".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DANGEROUS_PATH:location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DANGEROUS_PATH:threat]": ["wild beasts",
                ],
            "[SUMMARY]": [ "The {} is a dangerous place.".format(str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "the {} is home to many dangerous beasts".format(str(self.elements["LOCALE"])),
                ],
        }
        return mygram
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("This stretch of wilderness is completely untamed. You will have to find your way through it to get where you're going.")
            explo.check_trigger( "WIN", self )
            self._do_message = False

class BasicWildernessPath( SDIPlot ):
    LABEL = "SDI_DANGEROUS_PATH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    @classmethod
    def matches( self, pstate ):
        return pstate.rank > 1
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        myscene,mymapgen = randmaps.architect.design_scene( 60, 60,
          randmaps.ForestScene, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        self._do_message = True

        # Add an opportunity for extra treasure.
        self.add_sub_plot( nart, "SUPPLEMENTAL_TREASURE" )

        # Add some extra pressure.
        for t in range( random.randint(1,3) ):
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) != 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Create the scene entrance and exit on opposite ends of the map.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_PAIRS)
        myroom1 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_a )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom1.contents.append( myent )

        myroom2 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_b )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        myroom2.contents.append( myexit )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "crossing the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Travel to the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DANGEROUS_PATH:location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DANGEROUS_PATH:threat]": ["monsters",
                ],
            "[SUMMARY]": [ "There is a hidden danger in the {}.".format(str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "many have disappeared in the {}".format(str(self.elements["LOCALE"])),
                ],
        }
        return mygram
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("This wilderness area doesn't seem to be entirely uninhabited.")
            explo.check_trigger( "WIN", self )
            self._do_message = False



# SDI_DEFILED_PLACE
#   This place, a shrine or glade or whatnot, has been desecrated, blasphemed,
#   or just plain old ransacked.
# Win Condition:
#   Secure the area. May involve defeating leftover raiders, stabilizing a
#   magical meltdown, or what-have-you. Use your imagination!
# Grammar Tags:
#   [SDI_DEFILED_PLACE:location]    The name of the place that was defiled.
# To do:
# - Sacred Grove Burnt Down
# - Ransacked Temple
# - Grave Robbers: Bodies stolen, set enemy as undead faction
# - Grafitti: Set enemy as Chaos

class GroveBattle( SDIPlot ):
    LABEL = "SDI_DEFILED_PLACE"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Grove","{0} Forest")
    @classmethod
    def matches( self, pstate ):
        return ( pstate.rank > 2 and ( not pstate.elements.get("BIOME") or
                pstate.elements["BIOME"].biome in (context.HAB_FOREST,) ))
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.register_element( "BIOME", randmaps.architect.Forest() )
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        myscene,mymapgen = randmaps.architect.design_scene( 60, 60,
          randmaps.WildernessPath, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        ambush_room.priority = 50
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=300, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )
        myhab = myscene.get_encounter_request()
        myhab[context.MTY_BEAST] = True
        myhab[context.GEN_NATURE] = context.MAYBE
        friendlies = teams.Team( strength=150, default_reaction=characters.SAFELY_FRIENDLY,
         rank=self.rank, habitat=myhab)
        ambush_room.contents.append( friendlies )
        npc = self.register_element( "NPC",
         monsters.generate_npc(team=friendlies,rank=self.rank+1,upgrade=True,
         job=characters.Druid),dident="_AMBUSHROOM" )
        friendlies.boss = npc
        self._reward_ready = True
        self._do_message = True
        ambush_room.contents.append( waypoints.TreeStump(anchor=randmaps.anchors.middle,
         desc="You stand before the stump of what was once a mighty tree, before it was callously destroyed by the {}.".format(antagonist)
         ))

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        # After combat, the druid of the grove can provide temple services
        # if they survive.
        self.shop = services.Temple()

        # Add a reward if the PCs save the NPC.
        self.add_sub_plot( nart, "REWARD",
         PlotState(elements={"ORIGIN":npc}).based_on(self), ident="next" )
        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("The normal quiet of {} has been replaced by the sounds of conflict.".format(self.elements["LOCALE"]))
            self._do_message = False
    def t_COMBATOVER( self, explo ):
        if self._reward_ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.subplots["next"].active = True
            explo.check_trigger( "WIN", self )
            self._reward_ready = False
    def NPC_offers( self, explo ):
        ol = list()
        if not self._reward_ready:
            if self.subplots["next"].active:
                ol.append( dialogue.Offer( "Thanks for your help against the {}, but we were too late to save the blessed tree.".format(self.elements["ANTAGONIST"]) ,
                 context = context.ContextTag([context.HELLO]) ) )
            ol.append( dialogue.Offer( "[SERVICE_TEMPLE]" ,
             context = context.ContextTag([context.SERVICE,context.HEALING]), effect=self.shop ) )
        return ol
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "avenging the sacred tree of {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Seek the druid of {}.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [    "Your party decides to travel to {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_DEFILED_PLACE:location]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "not even the trees are safe",
                ],
            "[villainous_act]": [ "destroyed the sacred tree of {}".format(self.elements["LOCALE"]),
                ],
            "[villainous_motive]": [ "to drive out the druids",
                ],
            "[SUMMARY]": [ "The sacred tree of {} has been destroyed by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        if self.elements["NPC"].is_alright() and not self._reward_ready:
            mygram["[achievement]"] = [ "saving {} from the {}".format(self.elements["NPC"],self.elements["ANTAGONIST"]),
                ]
        return mygram


class ElementalShrine( SDIPlot ):
    LABEL = "SDI_DEFILED_PLACE"
    active = True
    scope = True
    NAME_PATTERNS = { context.DES_EARTH: "{} of Earth", context.DES_AIR: "{} of Air",
        context.DES_WATER: "{} of Water", context.DES_FIRE: "{} of Fire"
        }
    BUILDING_TYPES = ("Shrine","Temple")
    ELEMENTS = (context.DES_EARTH,context.DES_WATER,context.DES_AIR,context.DES_FIRE)
    INTRO_PROBLEM = { context.DES_EARTH: "the earth has begun to rot",
        context.DES_AIR: "the wind has stopped",
        context.DES_WATER: "the sea has gone wild",
        context.DES_FIRE: "the world is veiled in darkness"
        }
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        self._theme = random.choice( self.ELEMENTS )
        archi = self.register_element( "ARCHITECTURE",
         randmaps.architect.TempleArchitecture())
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"),secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.desctags.append( self._theme )
        myscene.name = self.NAME_PATTERNS[self._theme].format(random.choice( self.BUILDING_TYPES ))

        # Create the temple exterior.
        fortress = randmaps.rooms.CastleRoom( parent=myscene,width=21,height=21,
          tags=(context.GOAL,))
        exterior = randmaps.rooms.BuildingRoom( parent=fortress,
         tags=(context.CIVILIZED,) )
        exterior.special_c[ "window" ] = maps.SMALL_WINDOW
        gate_1 = waypoints.GateDoor()
        gate_1.mini_map_label = "Shrine"
        exterior.special_c[ "door" ] = gate_1

        interior,igen = randmaps.architect.design_scene( 40, 40,
          randmaps.BuildingScene, archi, setting=self.setting)
        self.register_scene( nart, interior, igen, ident="_TEMPLE", dident="LOCALE" )
        interior.desctags.append( self._theme )
        interior.name = "{} Interior".format( myscene.name )
        int_mainroom = randmaps.rooms.SharpRoom( width=9,height=9,
          anchor=randmaps.anchors.south, parent=interior )
        gate_2 = waypoints.GateDoor()
        int_mainroom.contents.append( gate_2 )
        int_mainroom.DECORATE = randmaps.decor.TempleDec()
        gate_2.anchor = randmaps.anchors.south

        crystal = self.register_element( "_CRYSTAL", waypoints.PowerCrystal(plot_locked=True))
        crystal.anchor = randmaps.anchors.middle
        int_mainroom.contents.append( crystal )

        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=0, habitat=myscene.get_encounter_request(), fac=antagonist,
         rank=self.rank, respawn=False ) )
        int_mainroom.contents.append( team )

        myhabitat = { self._theme: True, context.MTY_ELEMENTAL: context.MAYBE, context.MTY_CELESTIAL: context.MAYBE,
         (context.MTY_BEAST,context.MTY_UNDEAD,context.MTY_CONSTRUCT,context.MTY_CELESTIAL,context.MTY_ELEMENTAL): True,
         }
        btype = monsters.choose_monster_type(self.rank-1,self.rank+2,myhabitat)
        if btype:
            boss = self.register_element("_MONSTER",monsters.generate_boss( btype, self.rank+2, team=team ))
            boss.name = "Crystal Spirit"
            int_mainroom.contents.append( boss )

        gate_1.destination = interior
        gate_1.otherside = gate_2
        gate_2.destination = myscene
        gate_2.otherside = gate_1

        # Create the scene entrance and exit on opposite ends of the map.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_PAIRS)
        myroom1 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_a )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom1.contents.append( myent )

        myroom2 = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_b )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        myroom2.contents.append( myexit )
        myexit.plot_locked = True
        self._door_locked = True
        self._do_message = True

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return btype
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "pacifying the {}".format(self.elements["LOCALE"]),
                ],
            "[CONCLUSION]": ["The spirits at the {} have been pacified. [END_SHORTIE]".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Go see what has happened to the {}, and defend it if necessary.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]":  ["Your wanderings have brought you close to the {}. However, something seems to be wrong there.".format(self.elements["LOCALE"]),
                "There has been a series of bad omens; {}. Your party travels to the {} to discover the cause.".format(self.INTRO_PROBLEM[self._theme],self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DEFILED_PLACE:location]": [str(self.elements["LOCALE"]),
                ],
            # A special tag, used after the spirit is calmed.
            "[SDI_DEFILED_PLACE:ending]": [ "The question is, who would dare to desecrate this place?",
                "This must have been the work of [+SDI_BIGBOSS:name] the [SDI_BIGBOSS:type].",
                "This must be related to the trouble [quest_giver] warned you about.",
                "The ones who did this must have come from [+SDI_ENEMY_BARRACKS:name]; that's where you will find answers.",
                "Maybe you will discover who did this, and why, in [+location].",
                ],
            "[SUMMARY]": [ "There has been a disturbance at the {}.".format(str(self.elements["LOCALE"])),
                ],
            "[villainous_act]": [ "defiled the {}".format(self.elements["LOCALE"]),
                ],
            "[warning]": [ "the {} has been defiled".format(str(self.elements["LOCALE"])),
                self.INTRO_PROBLEM[self._theme]
                ],
        }
        return mygram
    def t_START( self, explo ):
        if self._do_message and explo.scene is self.elements["_TEMPLE"]:
            explo.alert("You sense evil as you enter the room. Without warning, the guardian of the crystal attacks!")
            self._do_message = False
            for m in explo.scene.contents:
                if hasattr(m,"team") and m.team is self.elements["TEAM"]:
                    explo.camp.activate_monster(m)
    def _open_the_exit( self,explo ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.check_trigger( "WIN", self )
    def _smash_crystal( self, explo ):
        if explo.bumper.get_stat( stats.STRENGTH ) + random.randint(1,20) > 20:
            explo.alert("You strike the crystal, shattering it into a million pieces. The crystal guardian lets out an otherworldly shriek before fading into nothingness.")
            self._open_the_exit( explo )
            self.elements["TEAM"].default_reaction = 999
            explo.scene.contents.remove(self.elements["_MONSTER"])
            explo.camp.fight.active.remove(self.elements["_MONSTER"])
            explo.alert("The spirit has been destroyed. [=SDI_DEFILED_PLACE:ending]")
        else:
            explo.alert("You strike the crystal, but don't even manage to scratch it.")
    def _repair_crystal( self, explo ):
        if (explo.bumper.get_stat( stats.MAGIC_ATTACK ) + explo.bumper.get_stat_bonus( stats.PIETY ) + random.randint(1,100)) > (45 + 4 * self.rank):
            explo.alert("You touch the crystal. You are overwhelmed by the negative energy...")
            explo.alert("Concentrating through the pain, you make mental contact with the crystal spirit. It peers deep into your soul, then decides you are not the one who attacked this place.")
            explo.alert("The spirit fades away. The crystal begins to glow with a steady light once more.")
            self._open_the_exit( explo )
            self.elements["TEAM"].default_reaction = 999
            explo.scene.contents.remove(self.elements["_MONSTER"])
            explo.give_gold_and_xp( 0, 100 * self.rank + 50 )
            explo.alert("The spirit has been calmed. [=SDI_DEFILED_PLACE:ending]")
            self.elements["_CRYSTAL"].plot_locked = False
        else:
            explo.alert("You touch the crystal. You are overwhelmed by the negative energy!")
            explo.invoke_effect( self.CRYSTAL_SHOCK, None, (explo.bumper.pos,) )
    CRYSTAL_SHOCK = effects.NoEffect( children = (
        effects.HealthDamage((1,6,0), stat_bonus=None, element=stats.RESIST_SOLAR, anim=animobs.YellowExplosion ),
        effects.ManaDamage((2,6,0), stat_bonus=None, anim=animobs.PurpleExplosion ),
    ))
    def _CRYSTAL_menu( self, thingmenu ):
        if self._door_locked:
            thingmenu.desc = "The elemental crystal is flickering wildly. Something terrible must have happened here."
            thingmenu.add_item( "Smash the crystal", self._smash_crystal )
            thingmenu.add_item( "Touch the crystal", self._repair_crystal )
            thingmenu.add_item( "Leave it alone", None )
        else:
            thingmenu.desc = "The elemental crystal has gone cold and dark."
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "You should find out what happened at the {} before leaving.".format(self.elements["LOCALE"])
    def t_COMBATOVER( self, explo ):
        if explo.scene is self.elements["_TEMPLE"] and self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            explo.alert("The spirit has been calmed. [=SDI_DEFILED_PLACE:ending]")
            self._open_the_exit(explo)

#  SDI_DUNGEON_ENTRANCE
#   There's a dungeon entrance. The entrance will probably determine the
#   architecture of the dungeon and the nature of its inhabitants.
# Win Condition:
#   Gain access to the dungeon. This may be as simple as showing up.
# Grammar Tags:
#   [SDI_DUNGEON_ENTRANCE:location]   The rough location of the dungeon
#   [SDI_DUNGEON_ENTRANCE:name]       The name of the dungeon
# To do:
# - Tunnel Dungeon
# - Building Dungeon

class InhabitedTunnelsDungeonEntrance( SDIPlot ):
    LABEL = "SDI_DUNGEON_ENTRANCE"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        antagonist = self.elements.setdefault( "ANTAGONIST",
          teams.AntagonistFaction(dungeon_type=["Tunnels","Catacombs"]) )
        myscene,mymapgen = randmaps.architect.design_scene( min(32+self.rank*3,60), min(32+self.rank*3,60),
          randmaps.ForestScene, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Add the scene entrance.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_CARDINALS)
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,anchor=anc_a )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        # Create the antagonist encampment.
        fortress = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(anchor=anc_b), dident="LOCALE" )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=150, habitat=myscene.get_encounter_request(), fac=antagonist,
         rank=self.rank, respawn=False ) )
        fortress.contents.append( team )
        mycart = waypoints.Cart()
        mycart.stock(self.rank)
        fortress.contents.append(mycart)
        fortress.contents.append(waypoints.Campsite())

        # Register the cave stuff.
        archi = self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.TunnelDungeon(antagonist) )
        archi.name = antagonist.name

        # Add a boss to guard the entrance.
        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = context.MAYBE
        myhabitat[(context.MTY_LEADER,context.MTY_BOSS)] = True
        antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank-1,self.rank+2,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+1, team=team )
            myitem = items.generate_special_item( self.rank )
            if myitem:
                boss.contents.append( myitem )
            fortress.contents.append( boss )
            team.boss = boss

        # Create the exit... which in this case is the fortress entrance.
        myexit = waypoints.DownEntrance()
        myexit.mini_map_label = "Tunnel Entrance"
        myexit.plot_locked = True
        self._door_locked = True
        fortress.contents.append( myexit )
        fortress.special_c["door"] = myexit

        # Add some extra pressure.
        if random.randint(1,4) != 4:
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,10) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "entering the {}".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
            "[GO_QUEST]": ["Locate the {} in the {}.".format(self.elements["DUNGEON_ARCHITECTURE"].name,self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DUNGEON_ENTRANCE:location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DUNGEON_ENTRANCE:name]": [self.elements["DUNGEON_ARCHITECTURE"].name,
                ],
            "[SUMMARY]": [ "The {} can be found in the {}.".format(self.elements["DUNGEON_ARCHITECTURE"].name,self.elements["LOCALE"]),
                ],
            "[warning]": [ "the {} are more than they appear".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
        }
        return mygram
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many guards around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the guards defeated, you are free to enter the {}.".format(self.elements["DUNGEON_ARCHITECTURE"].name))
            explo.check_trigger( "WIN", self )


class RuinedFortressDungeonEntrance( SDIPlot ):
    LABEL = "SDI_DUNGEON_ENTRANCE"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("Ruins of {0} Fortress","Ruins of {0} Castle")
    def custom_init( self, nart ):
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.TunnelDungeon(antagonist))
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"),secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        archi.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )
        myscene.name = "Outside the {}".format( archi.name )
        myscene.desctags.append( context.MTY_UNDEAD )

        # Create the fortress room and the guards.
        fortress = randmaps.rooms.CastleRoom( parent=myscene,width=21,height=21,
          tags=(context.GOAL,))
        myhabitat = myscene.get_encounter_request()
        myhabitat[context.MTY_UNDEAD] = True
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=150, habitat=myhabitat, rank=self.rank, respawn=False ) )
        fortress.contents.append( team )
        fortroom = randmaps.rooms.FuzzyRoom(parent=fortress)

        # Create the scene entrance
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice(randmaps.anchors.EDGES) )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        # Create the exit... which in this case is the fortress inside the walls.
        exterior = randmaps.rooms.BuildingRoom( parent=fortress,
         tags=(context.CIVILIZED,) )
        exterior.special_c[ "window" ] = maps.CASTLE_WINDOW
        myexit = waypoints.OpenGateDoor()
        myexit.mini_map_label = "Ruins"
        myexit.plot_locked = True
        exterior.special_c[ "door" ] = myexit
        self._door_locked = True

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "entering the {}".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
            "[GO_QUEST]": ["Locate the dungeon beneath the {}.".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DUNGEON_ENTRANCE:location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DUNGEON_ENTRANCE:name]": [self.elements["DUNGEON_ARCHITECTURE"].name,
                ],
            "[SUMMARY]": [ "There exists a dungeon beneath the {}.".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
            "[villainous_act]": [ "corrupted the {}".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
            "[warning]": [ "the {} are now haunted".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
        }
        return mygram
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many ghouls around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the restless dead dispatched, you are free to enter the ruins.")
            explo.check_trigger( "WIN", self )


class ThePitDungeonEntrance( SDIPlot ):
    LABEL = "SDI_DUNGEON_ENTRANCE"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    DNAME_PATTERNS = ("Pit of {0}","{0} Cavern")
    def custom_init( self, nart ):
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        antagonist = self.elements.get( "ANTAGONIST" )
        archi = self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.CavernDungeon(antagonist))
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting,secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )
        archi.name = random.choice( self.DNAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice(randmaps.anchors.EDGES) )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        # Create the exit room.
        fortress = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(tags=(context.GOAL,)), dident="LOCALE" )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=0, rank=self.rank, respawn=False ) )

        # Add a boss to guard the entrance.
        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_BEAST ] = True
        myhabitat[context.MTY_BOSS] = context.MAYBE
        btype = monsters.choose_monster_type(self.rank,self.rank+2,myhabitat)
        if btype:
            boss = self.register_element("BOSS",monsters.generate_boss( btype, self.rank+2, team=team ))
            fortress.contents.append( boss )

        # Create the exit... which in this case is the fortress entrance.
        myexit = waypoints.Pit()
        myexit.mini_map_label = archi.name
        myexit.plot_locked = True
        self._door_locked = True
        fortress.contents.append( myexit )

        # Add some extra pressure.
        if random.randint(1,4) != 4:
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,10) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return btype
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "defeating {}".format(self.elements["BOSS"]),
                ],
            "[GO_QUEST]": ["To enter the {} you must first defeat {}.".format(self.elements["DUNGEON_ARCHITECTURE"].name,self.elements["BOSS"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DUNGEON_ENTRANCE:location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DUNGEON_ENTRANCE:name]": [self.elements["DUNGEON_ARCHITECTURE"].name,
                ],
            "[SUMMARY]": [ "The {} is guarded by {}.".format(self.elements["DUNGEON_ARCHITECTURE"].name,self.elements["BOSS"]),
                ],
            "[warning]": [ "{} attacks anyone who tries to enter the {}".format(self.elements["BOSS"],self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
        }
        return mygram
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "{} will not allow you to enter the pit just yet.".format(self.elements["BOSS"])
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With {} defeated, you are free to enter the {}.".format(self.elements["BOSS"],self.elements["DUNGEON_ARCHITECTURE"].name))
            explo.check_trigger( "WIN", self )


class BasicCaveDungeonEntrance( SDIPlot ):
    LABEL = "SDI_DUNGEON_ENTRANCE"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    DNAME_PATTERNS = ("Caves of {0}","{0} Cavern")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.CavernDungeon(antagonist))
        myscene,mymapgen = randmaps.architect.design_scene( min(20+self.rank*4,60), min(20+self.rank*4,60),
          randmaps.ForestScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"),secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )
        archi.name = random.choice( self.DNAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( width=7,height=7,parent=myscene,
            anchor=random.choice(randmaps.anchors.EDGES) )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        # Create the fortress room.
        fortress = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.MountainRoom(width=7,height=7,
         tags=(context.GOAL,)), dident="LOCALE" )
        myexit = waypoints.DungeonEntrance()
        myexit.mini_map_label = archi.name
        fortress.contents.append( myexit )
        fortress.special_c["door"] = myexit

        self._ready = True

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "locating the {}".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
            "[GO_QUEST]": ["Go to the {}, where you will find the {}.".format(self.elements["LOCALE"],self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DUNGEON_ENTRANCE:location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_DUNGEON_ENTRANCE:name]": [self.elements["DUNGEON_ARCHITECTURE"].name,
                ],
            "[SUMMARY]": [ "The {} is located in the {}.".format(self.elements["DUNGEON_ARCHITECTURE"].name,str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "the {} is full of terrifying monsters".format(self.elements["DUNGEON_ARCHITECTURE"].name),
                ],
        }
        return mygram
    def t_START( self, explo ):
        if self._ready:
            explo.check_trigger( "WIN", self )
            self._ready = False

#  SDI_DUNGEON_LEVEL
#   There's a dungeon level. Unlike a fortress or whatnot, this dungeon level
#   is full of all kinds of monsters rather than a singular group.
# Win Condition:
#   Usually, just show up. Sometimes there may be an extra challenge.
# Grammar Tags:
#   [SDI_DUNGEON_LEVEL:name]       The name of the dungeon
#   [SDI_DUNGEON_LEVEL:threat]     The dangerous thing about this dungeon
# To do:
# - Tunnel Dungeon
# - Building Dungeon

class BasicDungeonLevel( SDIPlot ):
    # A simple dungeon level.
    LABEL = "SDI_DUNGEON_LEVEL"
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.CavernDungeon(antagonist) )
        myscene,mymapgen = randmaps.architect.design_scene( random.randint(50,65),
          random.randint(50,65), randmaps.CaveScene,
          biome, setting=self.setting, fac=None)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = biome.name

        # Determine room anchors.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_CARDINALS)

        team = self.register_element( "TEAM", 
         teams.Team(default_reaction=-999, rank=self.rank, strength=100,
         habitat=myscene.get_encounter_request(), fac=antagonist,
         respawn=False ))
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
          anchor=anc_a )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        goalroom.contents.append(door2)
        door2.plot_locked = True
        door2.anchor = anc_a
        self._door_locked = True
        mychest = waypoints.MediumChest()
        mychest.stock(self.rank)
        goalroom.contents.append( mychest )

        # 4-6 rooms, at least 2 of which are encounters and 1 of which is empty.
        n = random.randint(1,3)
        for t in range( n ):
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        myscene.contents.append( mymapgen.DEFAULT_ROOM() )
        if random.randint(1,3) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        else:
            self.add_sub_plot( nart, "DUTILITY_ROOM", PlotState().based_on( self ) )
        if random.randint(1,3) != 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )
        else:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState(elements={"ANTAGONIST":antagonist}).based_on( self ) )

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.GateDoor()
        door1.anchor = anc_b
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many monsters around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the monsters defeated, you are free to pass this way.")
            explo.check_trigger( "WIN", self )
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "exploring the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Explore the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_DUNGEON_LEVEL:name]": [str(self.elements["LOCALE"]),],
            "[SDI_DUNGEON_LEVEL:threat]": ["monsters",],
            "[SUMMARY]": [ "The {} is a dangerous place.".format(self.elements["LOCALE"]),
                ],
            "[warning]":    ["few who enter the {} return alive".format(self.elements["LOCALE"]),
                ],
        }
        return mygram

class DungeonMonsterLevel( SDIPlot ):
    # One big fight.
    LABEL = "SDI_DUNGEON_LEVEL"
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.TunnelDungeon(antagonist) )
        myscene,mymapgen = randmaps.architect.design_scene( random.randint(36,45),
          random.randint(36,45), randmaps.RandomScene,
          biome, setting=self.setting, fac=None)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        #mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.desctags.append( context.MTY_BEAST )
        myscene.name = biome.name

        # Determine room anchors.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_CARDINALS)

        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
          anchor=anc_a )
        door2 = waypoints.GateDoor()
        goalroom.contents.append(door2)
        door2.anchor = anc_a

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.GateDoor()
        door1.anchor = anc_b
        entranceroom.contents.append(door1)

        fightroom = mymapgen.DEFAULT_ROOM(anchor=randmaps.anchors.middle,parent=myscene)
        fightroom.DECORATE = randmaps.decor.CarnageDec(floor_fill_factor=0.15)
        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_BOSS ] = True
        myhabitat[(context.MTY_BEAST,context.MTY_CONSTRUCT,context.MTY_DRAGON)] = context.MAYBE
        btype = monsters.choose_monster_type(self.rank,self.rank+2,myhabitat)
        self._ready = True
        if btype:
            team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
             strength=160, rank=self.rank, habitat=myscene.get_encounter_request(), respawn=False ) )
            boss = monsters.generate_boss( btype, self.rank+2, team=team )
            fightroom.contents.append( boss )
            fightroom.contents.append( team )
            team.boss = boss
            for t in range(random.randint(2,3)):
                mychest = random.choice([waypoints.MediumChest,waypoints.SmallChest])()
                mychest.stock(self.rank)
                fightroom.contents.append( mychest )


        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return btype

    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "exploring the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Explore the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_DUNGEON_LEVEL:name]": [str(self.elements["LOCALE"]),],
            "[SDI_DUNGEON_LEVEL:threat]": ["monsters","beasts"],
            "[SUMMARY]": [ "The {} is full of dangerous beasts.".format(self.elements["LOCALE"]),
                ],
            "[villainous_motive]": [ "to build an army of monsters",
                ],
            "[warning]":    ["few who enter the {} return alive".format(self.elements["LOCALE"]),
                ],
        }
        return mygram
    def t_COMBATOVER( self, explo ):
        if self._ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self._ready = False
            explo.check_trigger( "WIN", self )


class WildDungeonLevel( SDIPlot ):
    # A simple dungeon level.
    LABEL = "SDI_DUNGEON_LEVEL"
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.CavernDungeon(antagonist) )
        myscene,mymapgen = randmaps.architect.design_scene( random.randint(50,65),
          random.randint(50,65), randmaps.CaveScene,
          biome, setting=self.setting, fac=None)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.desctags.append( context.MTY_BEAST )
        myscene.name = biome.name

        # Determine room anchors.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_CARDINALS)

        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
          anchor=anc_a )
        door2 = waypoints.GateDoor()
        goalroom.contents.append(door2)
        door2.anchor = anc_a
        self._ready = True

        if random.randint(1,2) == 1:
            team = self.register_element( "TEAM", 
             teams.Team(default_reaction=-999, rank=self.rank, strength=100,
             habitat=myscene.get_encounter_request(), fac=antagonist,
             respawn=False ))
            goalroom.contents.append( team )

        # 4-6 rooms, at least 2 of which are encounters and 1 of which is empty.
        n = random.randint(1,3)
        for t in range( n ):
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        myscene.contents.append( mymapgen.DEFAULT_ROOM() )
        if random.randint(1,3) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        else:
            self.add_sub_plot( nart, "DUTILITY_ROOM", PlotState().based_on( self ) )
        if random.randint(1,3) != 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )
        else:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState(elements={"ANTAGONIST":antagonist}).based_on( self ) )

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.GateDoor()
        door1.anchor = anc_b
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True
    def t_START( self, explo ):
        if self._ready:
            self._ready = False
            explo.alert("You hear a multitude of things scurrying in the distance.")
            explo.check_trigger( "WIN", self )
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "exploring the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Explore the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_DUNGEON_LEVEL:name]": [str(self.elements["LOCALE"]),],
            "[SDI_DUNGEON_LEVEL:threat]": ["monsters","beasts"],
            "[SUMMARY]": [ "The {} is full of dangerous beasts.".format(self.elements["LOCALE"]),
                ],
            "[warning]":    ["few who enter the {} return alive".format(self.elements["LOCALE"]),
                ],
        }
        return mygram

#  SDI_DUNGEON_TERROR
#   This level is some kind of deathtrap. Maybe there's a puzzle involved, or
#   maybe there's just an idiot ball. Either way, there is the distinct
#   possibility that your party won't be getting out in one piece.
# Win Condition:
#   Usually, just survive.
# Grammar Tags:
#   [SDI_DUNGEON_TERROR:location]   The name of the dungeon
#   [SDI_DUNGEON_TERROR:threat]     The dangerous thing about this dungeon
# To do:
# - Land of monster chests, aka the idiot ball special
# - Monster nest
# - Broken stairs
# - Oubliette with puzzle exit

class OneWayTripDungeon( SDIPlot ):
    # A simple dungeon level.
    LABEL = "SDI_DUNGEON_TERROR"
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.CavernDungeon(antagonist) )
        myscene,mymapgen = randmaps.architect.design_scene( random.randint(50,65),
          random.randint(50,65), randmaps.CaveScene,
          biome, setting=self.setting, fac=None)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.desctags.append( context.MTY_BEAST )
        myscene.name = biome.name

        granc = random.choice( randmaps.anchors.OPPOSING_CARDINALS )[0]
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
          anchor=granc )
        door2 = waypoints.GateDoor(anchor=granc)
        goalroom.contents.append(door2)
        self._ready = True

        if random.randint(1,2) == 1:
            team = self.register_element( "TEAM", 
             teams.Team(default_reaction=-999, rank=self.rank, strength=100,
             habitat=myscene.get_encounter_request(), fac=antagonist,
             respawn=False ))
            goalroom.contents.append( team )

        # 4-6 rooms, at least 2 of which are encounters and 1 of which is empty.
        n = random.randint(1,3)
        for t in range( n ):
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        myscene.contents.append( mymapgen.DEFAULT_ROOM() )
        if random.randint(1,3) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )
        else:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState(rank=self.rank+1).based_on( self ) )

        entranceroom = mymapgen.DEFAULT_ROOM( tags=(context.ENTRANCE,), parent=myscene )
        entranceroom.DECORATE = randmaps.decor.RockyDec()
        door1 = waypoints.Waypoint(anchor=randmaps.anchors.middle)
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True
    def t_START( self, explo ):
        if self._ready:
            self._ready = False
            explo.alert("As you are walking to the next level, the stairs collapse beneath you! You land in a pile of rubble.")
            explo.check_trigger( "WIN", self )
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "surviving the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Journey through the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_DUNGEON_TERROR:location]": [str(self.elements["LOCALE"]),],
            "[SDI_DUNGEON_TERROR:threat]": ["faulty architecture",],
            "[SUMMARY]": [ "No-one has returned from the {}.".format(self.elements["LOCALE"]),
                ],
            "[warning]":    ["once you go too deep you will not be able to turn back".format(self.elements["LOCALE"]),
                ],
        }
        return mygram


#  SDI_ENEMY_FORT
#   There's an enemy fortress to discover in the wilderness, and you need to
#   find a way in. In the simplest case this involves just fighting the guards
#   at the front door.
# Win Condition:
#   Gain access to the fortress. This may be as simple as showing up.
# Grammar Tags:
#   [SDI_ENEMY_FORT:location]   The rough location of the enemy fort
# To do:
# - Well-guarded and obvious fortress.
# - Pet guarded gate
# - Locked fortress
# - Can of Wyrms: Small courtyard full of enemies with unlocked puzzle door.
# - Unguarded fortress for low levels.

class BasicCaveHideout( SDIPlot ):
    LABEL = "SDI_ENEMY_FORT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice((randmaps.anchors.northwest,randmaps.anchors.northeast,
            randmaps.anchors.southwest,randmaps.anchors.southeast)) )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        # Create the fortress room.
        fortress = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.MountainRoom(tags=(context.GOAL,)), dident="LOCALE" )
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=150, habitat=myscene.get_encounter_request(), fac=antagonist,
         rank=self.rank, respawn=False ) )
        fortress.contents.append( team )

        # Register the cave stuff.
        self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.CavernDungeon(antagonist) )

        # Add a boss to guard the entrance.
        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_LEADER,context.MTY_FIGHTER)] = context.MAYBE
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank-3,self.rank+1,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+1, team=team )
            myitem = items.generate_special_item( self.rank )
            if myitem:
                boss.contents.append( myitem )
            fortress.contents.append( boss )
            team.boss = boss

        # Create the exit... which in this case is the fortress entrance.
        myexit = waypoints.DungeonEntrance()
        myexit.mini_map_label = "Cave Fortress"
        myexit.plot_locked = True
        self._door_locked = True
        fortress.contents.append( myexit )
        fortress.special_c["door"] = myexit

        # Add some extra pressure.
        if random.randint(1,4) != 4:
            self.add_sub_plot( nart, "ENCOUNTER" )
        if random.randint(1,4) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,10) == 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "locating the {} cave".format(self.elements["ANTAGONIST"]),
                ],
            "[GO_QUEST]": ["Gain access to the enemy fortress in the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_ENEMY_FORT:location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "The {} have been spotted near a cave in the {}.".format(self.elements["ANTAGONIST"],str(self.elements["LOCALE"])),
                ],
            "[warning]": [ "there is a cave in the {} which is home to the {}".format(str(self.elements["LOCALE"]),self.elements["ANTAGONIST"]),
                ],
        }
        return mygram
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many guards around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the guards defeated, you are free to enter the cave.")
            explo.check_trigger( "WIN", self )

class GuardedFortress( SDIPlot ):
    LABEL = "SDI_ENEMY_FORT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area.
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.BuildingDungeon(antagonist))
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"),secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        mymapgen.GAPFILL = randmaps.gapfiller.MonsterFiller(1,5,20)
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Create the fortress room and the guards.
        fortress = randmaps.rooms.CastleRoom( parent=myscene,width=21,height=21,
          tags=(context.GOAL,))
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=150, habitat=myscene.get_encounter_request(), fac=antagonist,
         rank=self.rank, respawn=False ) )
        fortress.contents.append( team )
        fortroom = randmaps.rooms.FuzzyRoom(parent=fortress)

        # Also add a reward- either straight up treasure chests, or an NPC boss
        # who will probably be carrying some nice gear.
        if random.randint(1,2) == 1:
            boss = monsters.generate_npc( rank=self.rank, team=team, fac=antagonist, upgrade=True )
            fortress.contents.append( boss )
            team.boss = boss
        else:
            mychest = waypoints.MediumChest()
            mychest.stock(self.rank)
            fortroom.contents.append( mychest )

        # Create the scene entrance
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice((randmaps.anchors.northwest,randmaps.anchors.northeast,
            randmaps.anchors.southwest,randmaps.anchors.southeast)) )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        # Create the exit... which in this case is the fortress inside the walls.
        exterior = randmaps.rooms.BuildingRoom( parent=fortress,
         tags=(context.CIVILIZED,) )
        exterior.special_c[ "window" ] = maps.CASTLE_WINDOW
        myexit = waypoints.GateDoor()
        myexit.mini_map_label = "Fortress"
        myexit.plot_locked = True
        exterior.special_c[ "door" ] = myexit
        self._door_locked = True

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "raiding the enemy base",
                ],
            "[GO_QUEST]": ["Gain access to the enemy fortress in the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_ENEMY_FORT:location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "There's an enemy base in the {}.".format(str(self.elements["LOCALE"])),
                ],
            "[villainous_motive]": [ "to conquer all of the free lands",
                ],
            "[warning]": [ "the fortress in the {} is very well guarded".format(str(self.elements["LOCALE"])),
                ],
        }
        return mygram
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many guards around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the guards defeated, you are free to enter the fortress.")
            explo.check_trigger( "WIN", self )

class UnguardedFortress( SDIPlot ):
    # A fortress entrance minus combat for low level adventurers.
    LABEL = "SDI_ENEMY_FORT"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Wilds","{0} Wilderness")
    @classmethod
    def matches( self, pstate ):
        """Only appears at the lower to mid levels."""
        return pstate.rank < 7
    def custom_init( self, nart ):
        # Create the scene for the fortress, and make sure there's an antagonist.
        antagonist = self.elements.setdefault( "ANTAGONIST",teams.AntagonistFaction() )
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.BuildingDungeon(antagonist))
        myscene,mymapgen = randmaps.architect.design_scene( 30+self.rank*5, 30+self.rank*5,
          randmaps.ForestScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"),secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Create the fortress room.
        clearing = randmaps.rooms.FuzzyRoom(width=15,height=15,parent=myscene)
        fortress = randmaps.rooms.BuildingRoom( width=12,height=7,parent=clearing,
         tags=(context.CIVILIZED,) )
        fortress.special_c[ "window" ] = maps.CASTLE_WINDOW
        myexit = waypoints.GateDoor()
        myexit.mini_map_label = "Fortress"
        fortress.special_c[ "door" ] = myexit

        # Create the scene entrance
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene,
            anchor=random.choice(randmaps.anchors.EDGES) )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )

        self._ready = True

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "locating the {} base".format(self.elements["ANTAGONIST"]),
                ],
            "[GO_QUEST]": ["Go to the {}; there you will find the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SDI_ENEMY_FORT:location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "The {} base is in the {}.".format(self.elements["ANTAGONIST"],self.elements["LOCALE"]),
                ],
            "[warning]": [ "the {} is home to the {}".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        return mygram
    def t_START( self, explo ):
        if self._ready:
            explo.check_trigger( "WIN", self )
            self._ready = False


# SDI_ENEMY_BARRACKS
#   The active base of a particular faction or group of monsters, as opposed to
#   a ruin or natural cave system.
#
# Win Condition:
#   Establish control or just get through it.
# Grammar Tags:
#   [SDI_ENEMY_BARRACKS:name]   The name of the base
# To do:
# - Monty Hall: Open doors, maybe find treasure, maybe find monsters
# - Proving Ground: Includes one big room with a huge encounter
#

class BasicBarracks( SDIPlot ):
    # A simple dungeon level.
    LABEL = "SDI_ENEMY_BARRACKS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Barracks","{0} Base")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon(antagonist) )
        myscene,mymapgen = randmaps.architect.design_scene( random.randint(50,65),
          random.randint(50,65), randmaps.SubtleMonkeyTunnelScene,
          biome, setting=self.setting, fac=antagonist)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( antagonist )
        myscene.desctags.append( context.MTY_HUMANOID )
        mymapgen.GAPFILL = None

        # Determine room anchors.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_CARDINALS)

        team = self.register_element( "TEAM", 
         teams.Team(default_reaction=-999, rank=self.rank, strength=100,
         habitat=myscene.get_encounter_request(), fac=antagonist,
         respawn=False ))
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
          anchor=anc_a )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        goalroom.contents.append(door2)
        door2.plot_locked = True
        door2.anchor = anc_a
        self._door_locked = True
        mychest = waypoints.MediumChest()
        mychest.stock(self.rank)
        goalroom.contents.append( mychest )

        n = random.randint(1,3)
        for t in range( n ):
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        for t in range( 4-n ):
            self.add_sub_plot( nart, "DUTILITY_ROOM", PlotState().based_on( self ) )
        if random.randint(1,3) == 1:
            self.add_sub_plot( nart, "SPECIAL_FEATURE" )
        if random.randint(1,3) != 1:
            self.add_sub_plot( nart, "SPECIAL_ENCOUNTER" )

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.GateDoor()
        door1.anchor = anc_b
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True
    def OUT_ENTRANCE_menu( self, thingmenu ):
        thingmenu.desc = "There are too many guards around for you to enter yet."
    def t_COMBATOVER( self, explo ):
        if self._door_locked and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.elements["OUT_ENTRANCE"].plot_locked = False
            self._door_locked = False
            explo.alert("With the guards defeated, you are free to pass this way.")
            explo.check_trigger( "WIN", self )
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "infiltrating the {}".format(self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["Infiltrate the {}.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_ENEMY_BARRACKS:name]": [str(self.elements["LOCALE"]),],
            "[SUMMARY]": [ "The {} have many soldiers at their base.".format(str(self.elements["ANTAGONIST"])),
                ],
            "[villainous_motive]": [ "to build a powerful army",
                ],
            "[warning]":    ["few who enter {} return alive".format(self.elements["LOCALE"]),
                ],
        }
        return mygram

# SDI_ENEMY_TERRITORY
#   You have to pass through an area controlled by enemies. Since enemies are
#   a prerequisite, this component needs/generates an antagonist.
# Win Condition:
#   Get through it. Or just show up. Whatever.
# Grammar Tags:
#   [SDI_ENEMY_TERRITORY:name]   The name of the antagonist faction
# To do:
#

class EasyScoutBattle( SDIPlot ):
    LABEL = "SDI_ENEMY_TERRITORY"
    active = True
    scope = "LOCALE"
    @classmethod
    def matches( self, pstate ):
        return pstate.rank <= 6
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        myscene,mymapgen = randmaps.architect.design_scene( 60, 60,
          randmaps.WildernessPath, biome, setting=self.setting)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = biome.name

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        ambush_room.priority = 50
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )

        self._ready = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def t_COMBATOVER( self, explo ):
        if self._ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            explo.alert("This was merely a scouting party; you should leave this place quickly before the {} discover where you are.".format(self.elements["ANTAGONIST"]))
            explo.check_trigger( "WIN", self )
            self._ready = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["Travel to the {}, and find out whether the {} have reached there yet.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[INTRO]": [ "You accidentally wandered into {}, which recently came under the control of the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_ENEMY_TERRITORY:name]": [ str(self.elements["ANTAGONIST"]),],
            "[warning]": [  "the {} are planning to conquer this entire area".format(self.elements["ANTAGONIST"]),
                ],
            "[SUMMARY]": [ "The {} has been claimed by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        return mygram


class EnemyHasCheckpoint( SDIPlot ):
    # One big fight.
    LABEL = "SDI_ENEMY_TERRITORY"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{} Checkpoint","{} Territory")
    def custom_init( self, nart ):
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "DUNGEON_ARCHITECTURE",
         randmaps.architect.BuildingDungeon(antagonist))
        myscene,mymapgen = randmaps.architect.design_scene( 65,65,
          randmaps.ForestScene, biome, setting=self.setting,
          fac=antagonist,secondary=archi)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( antagonist )
        myscene.contents.append( randmaps.rooms.FuzzyRoom() )
        myscene.contents.append( randmaps.rooms.FuzzyRoom() )
        mymapgen.GAPFILL = None

        # Determine room anchors.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_PAIRS)

        goalroom = randmaps.rooms.FuzzyRoom( tags=(context.GOAL,), parent=myscene,
          anchor=anc_a )
        door2 = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        goalroom.contents.append(door2)

        entranceroom = randmaps.rooms.FuzzyRoom( tags=(context.ENTRANCE,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        entranceroom.contents.append(door1)

        fightroom = mymapgen.DEFAULT_ROOM(anchor=randmaps.anchors.middle,parent=myscene)
        self._ready = True
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, 
         strength=175, rank=self.rank, habitat=myscene.get_encounter_request(),
         fac=antagonist, respawn=False ) )
        boss = monsters.generate_npc( rank=self.rank+1, team=team, fac=antagonist, upgrade=True )
        fightroom.contents.append( boss )
        fightroom.contents.append( team )
        team.boss = boss

        for t in range( random.randint(1,3) ):
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True

    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["Get through the {}.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "This area has recently been claimed by the {}. [INTRO_PROBLEM]".format(self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_ENEMY_TERRITORY:name]": [str(self.elements["ANTAGONIST"]),],
            "[SUMMARY]": [ "The {} have been stopping travelers who get too close to their territory.".format(self.elements["ANTAGONIST"]),
                ],
        }
        return mygram
    def t_COMBATOVER( self, explo ):
        if self._ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self._ready = False
            explo.check_trigger( "WIN", self )


# SDI_EVILPLAN
#   You walk in on an evil plan that you obviously have to stop.
# Win Condition:
#   Foil the plan.
# Grammar Tags:
#   [SDI_EVILPLAN:location]    The place where it'll be carried out.
#   [SDI_EVILPLAN:threat]     The nature of the plan.
# To do:
# - Human sacrifice
# - Summon a monster/demon/deity
# - Building a construct

class PlanningForWar( SDIPlot ):
    # The enemies are building weapons for war. Destroy their factory.
    LABEL = "SDI_EVILPLAN"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Workshop","{0} Factorium")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.setdefault( "ANTAGONIST",
          teams.AntagonistFaction(primary=context.GEN_KINGDOM) )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon() )
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.SubtleMonkeyTunnelScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        team = self.register_element("_TEAM",teams.Team(default_reaction=-999, rank=self.rank, strength=200,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False ))
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        goalroom.contents.append(door2)
        mychest = waypoints.LargeChest()
        mychest.stock(self.rank+1)
        goalroom.contents.append( mychest )

        forge = self.register_element( "TARGET",
          waypoints.Forge( desc="The {} are using this magical forge to contruct their weapons. It must be destroyed to stop their war machine.".format(antagonist),
          plot_locked=True, anchor=randmaps.anchors.middle ))
        goalroom.contents.append( forge )

        if self.rank < random.randint(4,7):
            brank = self.rank + 2
        else:
            brank = self.rank + 3
        boss = monsters.generate_npc( rank=brank, team=team, fac=antagonist, upgrade=True )
        goalroom.contents.append( boss )
        self.register_element( "ENEMY", boss )
        team.boss = boss
        myscene.name = random.choice( self.NAME_PATTERNS ).format( antagonist )

        self.add_sub_plot( nart, "ENCOUNTER" )
        self.add_sub_plot( nart, "PB_DESTROY", ident="_DESTROY" )
        self.enemy_ok = True
        self.forge_destroyed = False
        self.message_ready = True

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.southwest,randmaps.anchors.south,randmaps.anchors.southeast)) )
        door1 = waypoints.GateDoor()
        door1.anchor = randmaps.anchors.south
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True

    def _DESTROY_WIN( self, explo ):
        self.forge_destroyed = True
        self.elements["TARGET"].desc = "This forge has been rendered unusable. The {} war machine has been stopped.".format(self.elements["ANTAGONIST"])
        self.elements["TARGET"].cool_down()
        if not self.enemy_ok:
            explo.check_trigger( "WIN", self )
    def t_START( self, explo ):
        if self.message_ready:
            explo.alert( "You smell burning coals and hear the sound of metal on metal. The {} are preparing for war.".format(self.elements["ANTAGONIST"]) )
            self.message_ready = False
    def t_COMBATOVER( self, explo ):
        if self.enemy_ok and not self.elements["_TEAM"].members_in_play( explo.scene ):
            self.enemy_ok = False
            if self.forge_destroyed:
                explo.check_trigger( "WIN", self )
            else:
                explo.alert("{} has been defeated, but you must destroy the forge to end the {} war machine.".format(self.elements["ENEMY"],self.elements["ANTAGONIST"]))
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "stopping the {} war machine".format(self.elements["ANTAGONIST"]),
                "destroying {}'s magical forge".format(self.elements["ENEMY"]),
                ],
            "[CONCLUSION]": [ "{} [villainous_act] [villainous_motive], but you put a stop to their [negative_adjective] plans. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{}'s plan [villainous_motive] has been defeated. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{} [villainous_act], but didn't count on you [-achievement]. [END_SHORTIE]".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Locate the {} and put a halt to their weapon production.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_EVILPLAN:location]": [str(self.elements["LOCALE"]),],
            "[SDI_EVILPLAN:threat]": ["the {} are preparing for war".format(self.elements["ANTAGONIST"]),],
            "[SUMMARY]": [ "{} the {} is forging magical weapons for the {}.".format(str(self.elements["ENEMY"]),self.elements["ENEMY"].mr_level.name,self.elements["ANTAGONIST"]),
                ],
            "[warning]":    ["{} will kill anyone that opposes {}".format(self.elements["ENEMY"],self.elements["ENEMY"].object_pronoun()),
                ],
        }
        return mygram


# SDI_BLOCKED_GATE

# SDI_HIDDEN_BASE

# SDI_WILD_DUNGEON

# SDI_SUPERWEAPON

# SDI_BIGBOSS
#
# Win Condition:
#   Kill the boss, usually.
# Grammar Tags:
#   [SDI_BIGBOSS:name]   The name of the boss
#   [SDI_BIGBOSS:type]   The type of the boss (optional)
# To do:
# - Smaller boss with a big pet

class DragonBoss( SDIPlot ):
    # A simple building level with a direct bossfight.
    LABEL = "SDI_BIGBOSS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Lair","{0}'s Den","{0}'s Cave")
    @classmethod
    def matches( self, pstate ):
        """Only appears at the higher levels."""
        return pstate.rank > 3
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.setdefault( "ANTAGONIST",
          teams.AntagonistFaction(primary=context.GEN_DRAGON) )
        # We really want this dragon's lair to be a cave. If the dungeon
        # architecture is already a cave- great! Keep it. Otherwise, forget
        # about it and generate a cave.
        cdungeon = randmaps.architect.CavernDungeon()
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",cdungeon )
        if biome.biome != context.HAB_CAVE:
            biome = cdungeon
        myscene,mymapgen = randmaps.architect.design_scene( min(30+self.rank,50),min(30+self.rank,50),
          randmaps.CaveScene, biome, setting=self.setting,
          fac=antagonist)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        anc_a,anc_b = random.choice( randmaps.anchors.OPPOSING_CARDINALS )
        team = teams.Team(default_reaction=-999, rank=self.rank, strength=200,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.FuzzyRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_a )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor(anchor=anc_a)
        goalroom.contents.append(door2)
        for t in range(2):
            mychest = random.choice([waypoints.MediumChest,waypoints.LargeChest])()
            mychest.stock(self.rank+1)
            goalroom.contents.append( mychest )

        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_DRAGON ] = True
        myhabitat[(context.MTY_BOSS,context.MTY_LEADER,context.MTY_FIGHTER,context.MTY_MAGE)] = True
        btype = monsters.choose_monster_type(self.rank+2,self.rank+3,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+3, team=team )
            goalroom.contents.append( boss )
            self.register_element( "ENEMY", boss )
            team.boss = boss
            myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )
            self.enemy_defeated = False

        entranceroom = randmaps.rooms.FuzzyRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.StairsUp(anchor=anc_b)
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return btype

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True
        explo.check_trigger( "WIN", self )
    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "slaying {}".format(self.elements["ENEMY"]),
                ],
            "[CONCLUSION]": [ "{} [villainous_act] [villainous_motive], but you put a stop to its evil plans. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{}'s plan [villainous_motive] has been defeated. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{} [villainous_act], but didn't count on you [-achievement]. [END_SHORTIE]".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Slay {} the {}.".format(self.elements["ENEMY"],self.elements["ENEMY"].monster_name),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBOSS:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBOSS:type]": [self.elements["ENEMY"].monster_name,],
            "[SUMMARY]": [ "{} commands the {} from its lair.".format(self.elements["ENEMY"],self.elements["ANTAGONIST"]),
                "{} [villainous_act].".format(self.elements["ENEMY"]),
                "{} wants [villainous_motive].".format(self.elements["ENEMY"]),
                ],
            "[villainous_motive]": [ "to steal even more treasure",
                ],
            "[warning]":    ["{} is a powerful {}".format(self.elements["ENEMY"],self.elements["ENEMY"].monster_name),
                ],
        }
        return mygram


class InstantBoss( SDIPlot ):
    # A simple building level with a direct bossfight.
    LABEL = "SDI_BIGBOSS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Lair","{0}'s Sanctum")
    @classmethod
    def matches( self, pstate ):
        """Only appears at the lower levels."""
        return pstate.rank <= 5
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon() )
        myscene,mymapgen = randmaps.architect.design_scene( 30, 30,
          randmaps.SubtleMonkeyTunnelScene, biome, setting=self.setting,
          fac=antagonist)
        mymapgen.GAPFILL = None
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        anc_a,anc_b = random.choice( randmaps.anchors.OPPOSING_CARDINALS )
        team = teams.Team(default_reaction=-999, rank=self.rank, strength=200,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_a )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor(anchor=anc_a)
        goalroom.contents.append(door2)
        mychest = waypoints.MediumChest()
        mychest.stock(self.rank+1)
        goalroom.contents.append( mychest )

        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_BEAST ] = False
        myhabitat[(context.MTY_BOSS,context.MTY_LEADER,context.MTY_FIGHTER,context.MTY_MAGE)] = True
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank,self.rank+2,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+3, team=team )
        else:
            boss = monsters.generate_npc( rank=self.rank+2, team=team, fac=antagonist, upgrade=True )
            boss.monster_name = boss.mr_level.name

        myitem = items.generate_special_item( self.rank+1 )
        if myitem:
            boss.contents.append( myitem )
        goalroom.contents.append( boss )
        self.register_element( "ENEMY", boss )
        team.boss = boss
        myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )
        self.enemy_defeated = False

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = anc_b )
        door1 = waypoints.GateDoor(anchor=anc_b)
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True
        explo.check_trigger( "WIN", self )
    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "defeating {}".format(self.elements["ENEMY"]),
                ],
            "[CONCLUSION]": [ "{} [villainous_act] [villainous_motive], but you put a stop to their evil plans. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{}'s plan [villainous_motive] has been defeated. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{} [villainous_act], but didn't count on you [-achievement]. [END_SHORTIE]".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Defeat {}.".format(self.elements["ENEMY"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBOSS:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBOSS:type]": [self.elements["ENEMY"].monster_name,],
            "[SUMMARY]": [ "{} is preparing for evil acts.".format(str(self.elements["ENEMY"])),
                "{} [villainous_act].".format(self.elements["ENEMY"]),
                "{} wants [villainous_motive].".format(self.elements["ENEMY"]),
                ],
            "[warning]":    ["{} is a dangerous {}".format(self.elements["ENEMY"],self.elements["ENEMY"].monster_name),
                ],
        }
        return mygram


class BossInABox( SDIPlot ):
    # A simple building level, ending in a bossfight.
    LABEL = "SDI_BIGBOSS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Hideout","{0}'s Sanctum")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon() )
        myscene,mymapgen = randmaps.architect.design_scene( 45, 45,
          randmaps.SubtleMonkeyTunnelScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        team = teams.Team(default_reaction=-999, rank=self.rank, strength=200,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.northwest,randmaps.anchors.north,randmaps.anchors.northeast)) )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        door2.anchor = randmaps.anchors.north
        goalroom.contents.append(door2)
        mychest = waypoints.LargeChest()
        mychest.stock(self.rank+1)
        goalroom.contents.append( mychest )

        myhabitat = myscene.get_encounter_request()
        myhabitat[ context.MTY_HUMANOID ] = True
        myhabitat[(context.MTY_BOSS,context.MTY_LEADER,context.MTY_FIGHTER,context.MTY_MAGE)] = True
        if antagonist:
            antagonist.alter_monster_request( myhabitat )
        btype = monsters.choose_monster_type(self.rank,self.rank+2,myhabitat)
        if btype:
            boss = monsters.generate_boss( btype, self.rank+3, team=team )
            myitem = items.generate_special_item( self.rank+1 )
            if myitem:
                boss.contents.append( myitem )
            goalroom.contents.append( boss )
            self.register_element( "ENEMY", boss )
            team.boss = boss
            myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )

        if random.randint(1,10) <= self.rank:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        self.enemy_defeated = False

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.southwest,randmaps.anchors.south,randmaps.anchors.southeast)) )
        door1 = waypoints.GateDoor()
        door1.anchor = randmaps.anchors.south
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return btype

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True
        explo.check_trigger( "WIN", self )
    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "defeating {}".format(self.elements["ENEMY"]),
                ],
            "[CONCLUSION]": [ "{} [villainous_act] [villainous_motive], but you put a stop to their [negative_adjective] plans. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{}'s plan [villainous_motive] has been defeated. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{} [villainous_act], but didn't count on you [-achievement]. [END_SHORTIE]".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Defeat {}.".format(self.elements["ENEMY"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBOSS:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBOSS:type]": [self.elements["ENEMY"].monster_name,],
            "[SUMMARY]": [ "{} is a [negative_adjective] {}.".format(str(self.elements["ENEMY"]),self.elements["ENEMY"].monster_name),
                "{} [villainous_act].".format(self.elements["ENEMY"]),
                "{} wants [villainous_motive].".format(self.elements["ENEMY"]),
                ],
            "[warning]":    ["{} is a tough enemy".format(self.elements["ENEMY"]),
                ],
        }
        return mygram

class NPCBossInABox( SDIPlot ):
    # A simple building level, ending in a bossfight.
    LABEL = "SDI_BIGBOSS"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0}'s Hideout","{0}'s Sanctum")
    def custom_init( self, nart ):
        """Create the final dungeon, boss encounter, and resolution."""
        antagonist = self.elements.get( "ANTAGONIST" )
        biome = self.elements.setdefault( "DUNGEON_ARCHITECTURE",
          randmaps.architect.BuildingDungeon() )
        myscene,mymapgen = randmaps.architect.design_scene( 45, 45,
          randmaps.SubtleMonkeyTunnelScene, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )

        team = teams.Team(default_reaction=-999, rank=self.rank, strength=250,
         habitat=myscene.get_encounter_request(), fac=antagonist, respawn=False )
        goalroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.northwest,randmaps.anchors.north,randmaps.anchors.northeast)) )
        goalroom.contents.append( team )
        door2 = waypoints.GateDoor()
        door2.anchor = randmaps.anchors.north
        goalroom.contents.append(door2)
        mychest = waypoints.LargeChest()
        mychest.stock(self.rank+1)
        goalroom.contents.append( mychest )

        if self.rank < random.randint(2,4):
            brank = self.rank + 2
        elif self.rank < random.randint(6,10):
            brank = self.rank + 3
        else:
            brank = self.rank + 4
        boss = monsters.generate_npc( rank=brank, team=team, fac=antagonist, upgrade=True )
        goalroom.contents.append( boss )
        self.register_element( "ENEMY", boss )
        team.boss = boss
        myscene.name = random.choice( self.NAME_PATTERNS ).format( boss )

        if random.randint(1,10) <= self.rank:
            self.add_sub_plot( nart, "ENCOUNTER", PlotState().based_on( self ) )
        self.enemy_defeated = False

        entranceroom = randmaps.rooms.SharpRoom( tags=(context.GOAL,), parent=myscene,
            anchor = random.choice((randmaps.anchors.southwest,randmaps.anchors.south,randmaps.anchors.southeast)) )
        door1 = waypoints.GateDoor()
        door1.anchor = randmaps.anchors.south
        entranceroom.contents.append(door1)

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", door1 )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", door2 )

        return True

    def ENEMY_DEATH( self, explo ):
        self.enemy_defeated = True
        explo.check_trigger( "WIN", self )
    def t_COMBATOVER( self, explo ):
        if self.enemy_defeated:
            self.active = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "defeating {}".format(self.elements["ENEMY"]),
                ],
            "[CONCLUSION]": [ "{} [villainous_act] [villainous_motive], but you put a stop to their [negative_adjective] plans. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{}'s plan [villainous_motive] has been defeated. [END_SHORTIE]".format(self.elements["ENEMY"]),
                "{} [villainous_act], but didn't count on you [-achievement]. [END_SHORTIE]".format(self.elements["ENEMY"]),
                ],
            "[GO_QUEST]": ["Defeat {}.".format(self.elements["ENEMY"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_BIGBOSS:name]": [str(self.elements["ENEMY"]),],
            "[SDI_BIGBOSS:type]": [self.elements["ENEMY"].mr_level.name,],
            "[SUMMARY]": [ "{} is an evil {}.".format(str(self.elements["ENEMY"]),self.elements["ENEMY"].mr_level.name),
                "{} [villainous_act].".format(self.elements["ENEMY"]),
                "{} wants [villainous_motive].".format(self.elements["ENEMY"]),
                ],
            "[warning]":    ["{} will kill anyone that opposes {}".format(self.elements["ENEMY"],self.elements["ENEMY"].object_pronoun()),
                ],
        }
        return mygram


# SDI_AMBUSH
# The party has been ambushed! Oh noes!
#
# Win Condition:
#   Just show up, usually. Surviving is its own reward.
# Grammar Tags:
#   "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
# To do:
# - Novice ambush: Arrive after caravan destroyed, talk to survivors, no fight.
# - Too late ambush: Arrive after destruction, fight beasts at site. After
#   battle get message confirming that humanoids were behind the attack.
# - Trap ambush: Find destroyed caravan; searching cart brings out enemies.

class ImmediateAmbush( SDIPlot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    @classmethod
    def matches( self, pstate ):
        """Requires the SCENE to exist."""
        return pstate.rank > 2
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        myscene,mymapgen = randmaps.architect.design_scene( 40, 40,
          randmaps.WildernessPath, biome, setting=self.setting,
          fac=self.elements.get("ANTAGONIST"))
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        myent = waypoints.Waypoint()
        ambush_room.contents.append( myent )
        ambush_room.priority = 0
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )

        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )

        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("Without warning, you are ambushed by forces of the {}!".format(self.elements["ANTAGONIST"]))
            for m in explo.scene.contents:
                if hasattr(m,"team") and m.team is self.elements["TEAM"]:
                    explo.camp.activate_monster(m)
            explo.check_trigger( "WIN", self )
            self._do_message = False
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[achievement]": [ "battling the {} on the {}".format(self.elements["ANTAGONIST"],self.elements["LOCALE"]),
                ],
            "[GO_QUEST]": ["The {} will take you where you need to go.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "Your party decides to travel the {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                    "You travel to [+SDI_VILLAGE:name] for the annual [thing] festival. The path is peaceful and pleasant... too pleasant.",
                    "Raiders from the {1} have been attacking {0}. The leaders of [+SDI_VILLAGE:name] have offered a reward to bring [+SDI_BIGBOSS:name] to justice.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "danger awaits on the road ahead",
                ],
            "[SUMMARY]": [ "The {} has frequently been attacked by {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        return mygram


class AmbushInterrupted( SDIPlot ):
    LABEL = "SDI_AMBUSH"
    active = True
    scope = "LOCALE"
    NAME_PATTERNS = ("{0} Highway","{0} Road")
    def custom_init( self, nart ):
        # Create the scene where the ambush will happen- a wilderness area with
        # a road.
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        antagonist = self.elements.setdefault( "ANTAGONIST", teams.AntagonistFaction() )
        myscene,mymapgen = randmaps.architect.design_scene( 60, 60,
          randmaps.WildernessPath, biome, setting=self.setting,
          fac=antagonist)
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = random.choice( self.NAME_PATTERNS ).format( namegen.random_style_name() )

        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.Waypoint()
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the ambush room in the middle.
        ambush_room = self.register_element( "_AMBUSHROOM",
         randmaps.rooms.FuzzyRoom(), dident="LOCALE" )
        ambush_room.priority = 50
        team = self.register_element( "TEAM", teams.Team(default_reaction=-999, rank=self.rank, 
         strength=100, habitat=myscene.get_encounter_request(), fac=antagonist ) )
        ambush_room.contents.append( team )
        friendlies = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        npc = self.register_element( "NPC",
         monsters.generate_npc(team=friendlies,rank=self.rank+1,upgrade=True),
         dident="_AMBUSHROOM" )
        self._reward_ready = True
        self._do_message = True

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        # Add a reward if the PCs save the NPC.
        self.add_sub_plot( nart, "REWARD",
         PlotState(elements={"ORIGIN":npc}).based_on(self), ident="next" )
        return True
    def t_START( self, explo ):
        if self._do_message:
            explo.alert("You hear the sounds of conflict on the path ahead...")
            explo.check_trigger( "WIN", self )
            self._do_message = False
    def t_COMBATOVER( self, explo ):
        if self._reward_ready and not self.elements["TEAM"].members_in_play( explo.scene ):
            self.subplots["next"].active = True
            self._reward_ready = False
    def NPC_offers( self, explo ):
        ol = list()
        if not self._reward_ready:
            ol.append( dialogue.Offer( "Thanks for your help against the {}, but I fear [warning].".format(self.elements["ANTAGONIST"]) ,
             context = context.ContextTag([context.HELLO]) ) )
        return ol
    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["The {} will take you where you need to go.".format(self.elements["LOCALE"]),
                ],
            "[INTRO]": [    "Your party decides to travel the {}, seeking adventure. This area has recently been attacked by the {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                "You travel to [+SDI_VILLAGE:name]. This area has recently been attacked by the {}.".format(self.elements["ANTAGONIST"]),
                "Raiders from the {1} have been attacking {0}. The leaders of [+SDI_VILLAGE:name] have offered a reward to bring [+SDI_BIGBOSS:name] to justice.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),],
            "[SDI_AMBUSH:name]": [ str(self.elements["LOCALE"]),],
            "[warning]": [  "danger awaits on the road ahead",
                ],
            "[villainous_act]": [ "attacked {} on the {}".format(self.elements["NPC"],self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "The {} has frequently been attacked by {}.".format(self.elements["LOCALE"],self.elements["ANTAGONIST"]),
                ],
        }
        if self.elements["NPC"].is_alright() and not self._reward_ready:
            mygram["[achievement]"] = [ "saving {} from the {}".format(self.elements["NPC"],self.elements["ANTAGONIST"]),
                ]
        return mygram



# SDI_VILLAGE
#
# Win Condition:
#   Just show up, usually. A village is its own reward.
# Grammar Tags:
#    [SDI_VILLAGE:name] The village name
# To do:
# - Too late village: has already been destroyed, may find survivors. Or not.
# - Orc Prisoners: Village has been captured by orcs; rescue them from mine.
#   Survivors then help you find way to next chapter.
# - Dwarven village: Have to go underground to find it.
# - Elf village: Likewise hidden from plain sight.
# - Fort Under Siege: Barred from entering fort; doors will open after the
#   enemies have been defeated.
# - Hot Springs Village: Healing location, priestly stuff.
# - Nature Village: Druidish and rangerish stuff. Stonehenge?
# - Secret Magic Village: Wizardly stuff.
# - Athletic Village: Warrior stuff.
# - Hermit Village: Hey hey we're the monk-ees.

class BoringVillage( SDIPlot ):
    LABEL = "SDI_VILLAGE"
    # Create a small village. Add an NPC to provide advice and help.
    active = True
    scope = "LOCALE"
    def custom_init( self, nart ):
        """Create map, fill with city + services."""
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        archi = self.register_element( "ARCHITECTURE", randmaps.architect.Village(biome.biome))
        culture = self.register_element( "CULTURE", teams.PolisFaction(dungeon_type=("Village","Hamlet")) )
        myscene,mymapgen = randmaps.architect.design_scene( 80, 80,
          randmaps.WildernessPath, biome,fac=culture,secondary=archi,setting=self.setting)
        myscene.desctags.append( context.DES_CIVILIZED )
        self.register_scene( nart, myscene, mymapgen, ident="LOCALE" )
        myscene.name = culture.name

        castle = self.register_element( "CITY",
         randmaps.rooms.VillageRoom( width=25,height=25,anchor=randmaps.anchors.middle,
         tags=(context.CIVILIZED,context.ROOM_PUBLIC), parent=myscene ) )
        castle.priority = 50
        castleroom = randmaps.rooms.FuzzyRoom( tags=(context.ENTRANCE,), parent=castle )
        myteam = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        castle.contents.append( myteam )
        castleroom.contents.append( monsters.generate_npc(team=myteam,fac=culture) )
        castleroom.contents.append( monsters.generate_npc(team=myteam,fac=culture) )

        # Create the village elder.
        elder = monsters.generate_npc(team=myteam,rank=self.rank+1,
          job=monsters.base.Elder,upgrade=True,fac=culture)
        self.register_element("NPC",elder)
        castleroom.contents.append(elder)
        self._reward_given = False

        # Create the entrance at the beginning
        myroom = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        myroom.contents.append( myent )
        myroom.priority = 0

        # Create the exit on the end.
        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.priority = 100

        self._message_ready = True

        self.add_sub_plot( nart, "VILLAGE_RANDOMSHOP" )
        self.add_sub_plot( nart, "CITY_INN" )
        self.add_sub_plot( nart, "CITY_TEMPLE" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        #self.add_sub_plot( nart, "TEST_FEATURE", necessary=False )
        return True

    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["Travel to the {}.".format(self.elements["LOCALE"]),
                ],
            "[SDI_VILLAGE:name]": [ str(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "You arrive in the {}. [INTRO_PROBLEM]".format(self.elements["LOCALE"]),
                "This was supposed to be a nice relaxing trip to the {}. Of course, things rarely go according to plan for adventurers.".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "The {} has seen better times.".format(self.elements["LOCALE"]),
                "The {} lives in fear of [+SDI_BIGBOSS:name].".format(self.elements["LOCALE"]),
                "The {} is under attack by enemies who come from [+SDI_ENEMY_FORT:location].".format(self.elements["LOCALE"]),
                ],
            "[villainous_act]": [ "attacked the {}".format(self.elements["LOCALE"]),
                ],
            "[villainous_motive]": [ "to punish the {}".format(self.elements["LOCALE"]),
                "to conquer the {}".format(self.elements["LOCALE"])
                ],

        }
        if self._reward_given:
            mygram["[quest_giver]"] = [str(self.elements["NPC"]),]
        return mygram
    def accept_quest( self, explo ):
        self._reward(explo)
        self._reward_given = True
    def reject_quest( self, explo ):
        self.chapter.root.end_adventure(explo.camp)
    def NPC_offers( self, explo ):
        ol = list()
        if not hasattr( self, "_reward" ):
            # Generate aid for the NPC to give the party.
            self._reward = aid.ProvisionAid( self.rank, explo.camp,
             self.elements["NPC"],
             self.chapter.root.genplots[-1].elements.get("ENEMY"),
             self.elements.get("ANTAGONIST"))
        if self is not self.chapter.root.genplots[-1] and not self._reward_given:
            r1 = dialogue.Reply( "Yes, we will.",
             destination=dialogue.Offer( "[+GO_QUEST] {}".format( self._reward.get_speech() ),
             effect=self.accept_quest ) )
            r2 = dialogue.Reply( "No thanks.",
             destination=dialogue.Offer( "[REFUSE_QUEST]",
             effect=self.reject_quest ) )
            ol.append( dialogue.Offer( "[SHORTIE_SUMMARY] [SHORTIE_PROBLEM] Will you help us?",
             context = context.ContextTag([context.PROBLEM,context.LOCAL]),
             replies = [r1,r2] ) )
        else:
            pass
        return ol
    def t_START( self, explo ):
        if self._message_ready:
            self._message_ready = False
            explo.check_trigger( "WIN", self )

class DwarfVillage( SDIPlot ):
    LABEL = "SDI_VILLAGE"
    # Create a small village with excellent shopping.
    active = True
    scope = True
    def custom_init( self, nart ):
        """Create outside map, fill with wilderness."""
        biome = self.elements.setdefault( "BIOME", randmaps.architect.make_wilderness() )
        culture = self.register_element( "CULTURE",
          teams.PolisFaction(primary=context.GEN_TERRAN,dungeon_type=("Village","Halls")) )
        myscene,mymapgen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, biome,fac=culture,
          secondary=self.elements.get("ARCHITECTURE"),setting=self.setting)
        myscene.desctags.append( context.DES_CIVILIZED )
        self.register_scene( nart, myscene, mymapgen, ident="_OUTSIDE" )
        myscene.name = "Outside {}".format(culture.name)

        # Create the three outer rooms- entrance, village, exit.
        anc_a,anc_b = random.choice(randmaps.anchors.OPPOSING_PAIRS)
    
        first_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myent = waypoints.RoadSignBack(anchor=randmaps.anchors.middle)
        first_room.contents.append( myent )
        first_room.anchor = anc_a

        last_room = randmaps.rooms.FuzzyRoom( parent=myscene )
        myexit = waypoints.RoadSignForward(anchor=randmaps.anchors.middle)
        last_room.contents.append( myexit )
        last_room.anchor = anc_b

        v_room = randmaps.rooms.MountainRoom(parent=myscene)
        village_entrance = waypoints.MineEntrance()
        village_entrance.mini_map_label = culture.name
        v_room.contents.append( village_entrance )
        v_room.special_c["door"] = village_entrance

        # Create the cave for the village and add the contents.
        cave_biome = randmaps.architect.CavernDungeon()
        archi = self.register_element( "ARCHITECTURE", randmaps.architect.Village(context.HAB_CAVE))
        cave,cavegen = randmaps.architect.design_scene( 50, 50,
          randmaps.ForestScene, cave_biome,fac=culture,
          secondary=archi,setting=self.setting)
        self.register_scene( nart, cave, cavegen, ident="LOCALE" )
        cave.name = culture.name

        castle = self.register_element( "CITY",
         randmaps.rooms.VillageRoom( width=29,height=29,anchor=randmaps.anchors.middle,
         tags=(context.CIVILIZED,context.ROOM_PUBLIC), parent=cave ) )
        castleroom = randmaps.rooms.FuzzyRoom( tags=(context.ENTRANCE,), parent=castle )
        myteam = teams.Team( strength=0, default_reaction=characters.SAFELY_FRIENDLY)
        castle.contents.append( myteam )
        castleroom.contents.append( monsters.generate_npc(team=myteam,fac=culture) )
        castleroom.contents.append( monsters.generate_npc(team=myteam,fac=culture) )

        # Connect the cave-village to the outside world.
        vx_room = randmaps.rooms.FuzzyRoom(width=5,height=5,parent=cave,anchor=randmaps.anchors.north)
        village_exit = waypoints.StairsUp(anchor=randmaps.anchors.north)
        vx_room.contents.append( village_exit )
        village_exit.destination, village_exit.otherside = myscene,village_entrance
        village_entrance.destination, village_entrance.otherside = cave,village_exit

        # Create the village elder.
        elder = self.register_element("NPC",monsters.generate_npc(team=myteam,rank=self.rank+1,
          job=monsters.base.Elder,upgrade=True,fac=culture),dident="CITY")

        self._message_ready = True

        self.add_sub_plot( nart, "CITY_WEAPONSHOP",spstate=PlotState(rank=self.rank+random.randint(2,4)).based_on(self))
        self.add_sub_plot( nart, "CITY_ARMORSHOP",spstate=PlotState(rank=self.rank+random.randint(2,4)).based_on(self))
        self.add_sub_plot( nart, "CITY_INN" )
        self.add_sub_plot( nart, "CITY_TEMPLE" )

        # Save this component's data for the next component.
        self.register_element( "IN_SCENE", myscene )
        self.register_element( "IN_ENTRANCE", myent )
        self.register_element( "OUT_SCENE", myscene )
        self.register_element( "OUT_ENTRANCE", myexit )

        return True

    def get_sdi_grammar( self ):
        """Return a dict of grammar related to this plot."""
        mygram = {
            "[GO_QUEST]": ["Travel to the {}.".format(self.elements["LOCALE"]),
                ],
            "[SDI_VILLAGE:name]": [ str(self.elements["LOCALE"]),
                ],
            "[INTRO]": [ "You are going to the {}. [INTRO_PROBLEM]".format(self.elements["LOCALE"]),
                "You are traveling to the {}, renowned for its fine weapon- and armorsmiths. [INTRO_PROBLEM]".format(self.elements["LOCALE"]),
                ],
            "[location]": [str(self.elements["LOCALE"]),
                ],
            "[SUMMARY]": [ "The {} is in a dangerous place.".format(self.elements["LOCALE"]),
                ],
            "[villainous_act]": [ "forced the {} into hiding".format(self.elements["LOCALE"]),
                ],
            "[villainous_motive]": [ "to punish the {}".format(self.elements["LOCALE"]),
                "to destroy the {}".format(self.elements["LOCALE"])
                ],
            "[warning]": [ "you will be overcharged for everything in the {}".format(self.elements["LOCALE"]),
                ],
        }
        return mygram

    def get_dialogue_grammar( self, npc, explo ):
        if npc is self.elements["NPC"]:
            return {
                "[SDI_VILLAGE:Advice]": [
                    "[SHORTIE_SUMMARY] [SHORTIE_PROBLEM]", "[+GO_QUEST] But, [warning]!",
                    "You may know about [-achievement], but [+warning]!", "[RUMOUR] I'll bet they don't know that on the surface!"
                    ],
                "[SDI_VILLAGE:Hello]": [
                    "[HELLO] Here in the [scene] we are rarely bothered by the surface world, but there are things you should know."
                    ],
            }
    def NPC_offers( self, explo ):
        ol = list()
        ol.append( dialogue.Offer( "[SDI_VILLAGE:Advice]",
         context = context.ContextTag([context.INFO,context.HINT])))
        ol.append( dialogue.Offer( "[SDI_VILLAGE:Hello]",
         context = context.ContextTag([context.HELLO,context.INFO,context.HINT])))
        return ol

    def t_START( self, explo ):
        if self._message_ready and explo.camp.scene is self.elements["LOCALE"]:
            explo.alert("You step into a bustling dwarven village.")
            self._message_ready = False
            explo.check_trigger( "WIN", self )


# SDI_OUTPOST

# SDI_RECON


